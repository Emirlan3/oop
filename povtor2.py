"""Николай – оригинальный человек. 
Он решил создать класс Nikola, принимающий при инициализации 2 параметра: имя и возраст. Но на этом он не успокоился. 
Не важно, какое имя передаст пользователь при создании экземпляра, оно всегда будет содержать “Николая”. 
В частности - если пользователя на самом деле зовут Николаем, то с именем ничего не произойдет, 
а если его зовут, например, Максим, то оно преобразуется в “Я не Максим, а Николай”.
Более того, никаких других атрибутов и методов у экземпляра не может быть добавлено, 
даже если кто-то и вздумает так поступить 
(т.е. если некий пользователь решит прибавить к экземпляру свойство «отчество» или метод «приветствие», 
то ничего у такого хитреца не получится). """

class Nikola:
    __slots__ = ['name', 'age']
    def __init__(self, name, age):
        if name == 'Nikola':
            self.name == name
        else:
            self.name = f' я не {name}, а Николай'
        self.age = age


name_ = Nikola('Максим', 18)
person2 = Nikola('Николай', 56)
# print(name_.name, person2.name)

""" Герой.
# Разработайте программу по следующему описанию.
# В некой игре-стратегии есть солдаты(Solder) и герои(Hero).
# У всех есть свойство, содержащее уникальный номер объекта(id), и свойство в котором хранится принадлежность команде(team).

# У солдат есть статический метод "go_hero", который в качестве параметра принимает уникальный номер(id) героя. 
И возвращает 'Иду за героем {уникальный номер героя}'
# У героев есть атрибут класса 'level = 0' и есть метод увеличения собственного уровня 'level_up' 
который при вызове увеличивает уровень героя на единицу.
# В основной ветке программы создается по одному герою 'hero1' и 'hero2'.
#     hero1 = (1, 'Blue)
#     hero2 = (2, 'Red)
# В цикле генерируются объекты-солдаты(10 солдат). В списке obj1 будут храниться обьекты солдаты команды 'Blue', а в obj2 'Red'.
 Их принадлежность команде определяется случайно.
# Измеряется длина списков солдат противоборствующих команд и выводится на экран сообщение. 
Если количество солдат команды Blue больше команды Red, тогда выведете сообщение "Первый герой победил у него: 
{len(obj1)} солдат", если же количество солдат второй команды больше: 
"Второй герой победил у него: {len(obj2)} солдат" иначе "Количество солдат одинаковое!".
# Также у героя, принадлежащего команде с более длинным списком, поднимается уровень.
# Отправьте одного из солдат первого героя следовать за ним. Также вывидите уровень героев. """

# class Hero:
#     level = 0
#     def __init__(self, id_, team):
#         self.id_ = id_
#         self.team = team
#     def level_up(self):
#         self.id_ = id


#     @staticmethod
#     def go_hero(id_):
#         return f'иду за героем {id_}'

# hero1 = Hero(1, 'Blue')
# hero2 = Hero(1, 'red')

# obj1 = []
# obj2 = []

# import random

# for i in range(10):
#     res = random.choice('Blue', 'red')
#     print(res)
#     if res == 'red':
#         obj2.append(Soldier(random.randint(1, 1000), res))
#     else:
#         obj1.append(Soldier(random.randint(1, 1000), res))

# if len (obj1) > len(obj2):
#     hero1.level_up()
#     print(f'Первый герой победил у него: {len(obj1)} солдат')
# else:
#     hero1.level_up()
#     hero2.level_up()
#     print('количество солдат одинаковые')

# print(obj1[0].go_hero(hero1.id_))



